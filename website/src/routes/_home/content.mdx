import { Link } from "@tanstack/react-router";
import { BenchPlot } from "#/routes/_benchmarks/_runtime/-components/plot";
import { DownloadPlot } from "#/routes/_benchmarks/download/-components/plot";
import { Admonition } from "#/routes/blog/-components/admonition";

Welcome to the Schema Benchmarks project. This aims to compare the performance of different schema validation libraries in detail, including separating each step of the process.

## <Link to="/download">Download</Link>

We first test the bundle size of each library. This is important for browser usage, where this will affect download time.

We do this by compiling example usage files with [Rolldown](https://rolldown.rs/), and measuring the size of the output, both minified and unminified.

With minification:

<DownloadPlot minify="minified" />

Without minification:

<DownloadPlot minify="unminified" />

## Benchmarks

Runtime benchmarks are run in sequence, on a GitHub runner.

Steps benchmarked include:

### <Link to="/initialization">Initialization</Link>

Creating the schema itself. This is usually a one time cost.

```ts title="schemas.ts"
import * as v from "valibot";

export const personSchema = v.object({
  name: v.string(),
  age: v.number(),
});
export type Person = v.InferOutput<typeof personSchema>;
```

<BenchPlot type="initialization" />

<Admonition type="note">
  For graphs on this page, the best result for each library is shown.
</Admonition>

### <Link to="/validation">Validation</Link>

Checking if a given value matches the schema. Crucially, this is different to <Link to="#parsing">parsing</Link> because it doesn't return a new value.

```ts
import * as v from "valibot";
import { personSchema } from "./schemas";

if (v.is(personSchema, data)) {
  // data is narrowed to Person
}
```

Validating valid data:

<BenchPlot type="validation" dataType="valid" />

Validating invalid data:

<BenchPlot type="validation" dataType="invalid" />

<Admonition type="note">
  Some libraries only support validation (e.g. `ajv`) _or_ parsing (e.g. `zod`). In these cases, we
  categorise them accordingly.
</Admonition>

### <Link to="/parsing">Parsing</Link>

Checking if a given value matches the schema, **and** returning a new value. This will include any transformations.

```ts
import * as v from "valibot";
import { personSchema } from "./schemas";

const person = v.parse(personSchema, data);
// person is of type Person
```

<Admonition type="info">
  Libraries with an asterisk (\*) throw an error when parsing invalid data (and have no non-throwing
  equivalent), so the benchmark includes a try/catch - which may have an unknown performance impact.

Results with a dagger (â€ ) abort early when parsing invalid data, so will tend to be faster.

</Admonition>

Parsing valid data:

<BenchPlot type="parsing" dataType="valid" />

Parsing invalid data:

<BenchPlot type="parsing" dataType="invalid" />

### Tags

#### Optimizations

Some libraries utilise specific optimizations to improve performance. We specifically track:

- **JIT**: Libraries that use Just-In-Time compilation (usually via `new Function`) to generate optimized code at runtime, e.g. `arktype`
- **Precompiled**: Libraries that generate optimized code at build time, e.g. `typia`

#### Error handling

Some libraries support different error handling strategies. We specifically track:

- **All errors**: Parse the entire value before returning/throwing an error.
- **Abort early**: Return/throw an error as soon as an issue is found.
